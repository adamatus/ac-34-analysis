<!DOCTYPE html>
<html>
  <head>
    <title>America's Cup 34 Race Analyzer</title>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.css" />
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="libs/slider/css/slider.css"></script>

    <script src="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script language="javascript" type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="libs/slider/js/bootstrap-slider.js"></script>
    <style>
#map { height: 400px; }

.mark {
    fill: yellow;
    stroke: none;
}

.boat-marker {
    opacity: 1;
    stroke: none;
    fill: black;
}

.boat-marker-usa {
    fill: black;
}

.boat-marker-nzl {
    fill: red;
}

.boat-marker-heli {
    fill: blue;
}

.boat-marker-ump {
    fill: yellow;
}

.boat-marker-cam {
    fill: green;
}

.boat-marker-rc {
    fill: white;
}

.boat-marker-marshall {
    fill: gray;
}

.track {
    opacity: 1;
    stroke: black;
    stroke-width: 1px;
    fill: none;
}

.boat-stats-velocity {
    stroke-width: 2px;
    stroke: black;
}

.boat-stats-truewind {
    stroke-width: 2px;
    stroke: blue;
}

.boat-stats-appwind {
    stroke-width: 2px;
    stroke: cyan;
}

.track-usa {
    stroke: black;
}

.track-nzl,
.boat-stats-velocity-nzl {
    stroke: red;
}

.track-heli {
    stroke: blue;
}

.track-ump {
    stroke: yellow;
}

.track-cam {
    stroke: green;
}

.track-rc {
    stroke: white;
}

.track-marshall {
    stroke: gray;
}

.slider {
    margin: 10px;
    width: 700px;
}


    </style>
  </head>
  <body>
      <div class="container">
        <div id="map"></div>
        <input type="text" class="slider" value="0" id="time-slider" >
        <table id="summary-table" class="table table-striped table-hover">
            <thead>
                <tr><th>Boat</th><th>Speed</th><th>Dir</th><th>Apparent Spd</th><th>Apparent Angle</th></tr>
            </thead>
            <tbody>
            </tbody>
        <table>
      </div>
      <script>

var formatDate = d3.time.format('%d:%m:%Y');
var formatTime = d3.time.format('%H:%M:%S.%L');
var format = d3.time.format('%d:%m:%Y %H:%M:%S.%L %Z');

var timeMapper = d3.time.scale().domain([formatTime.parse("13:00:00.000"),formatTime.parse("13:40:04.000")]).range([0,1000]);

// Add the time slider
var ts = $('#time-slider').slider({min:0,max:1000,
                    step:1,
                    value:0,
                    selection:'before',
                    formater: function(value) {
                                return timeMapper.invert(value);
                              }
                  })
        .on('slide',function(ev) {
                updateBoatPos(ev.value);
                });

// Add the base CloudMade map
var map = L.map('map').setView([37.82022604148547, -122.4294090270996], 13);
L.tileLayer('http://{s}.tile.cloudmade.com/78f159c3ec8c4290b7854cf0471003ec/997/256/{z}/{x}/{y}.png', {
    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="http://cloudmade.com">CloudMade</a>',
    maxZoom: 18
}).addTo(map);

// Add initial SVG layer that we will build on
map._initPathRoot() 

// Add svg group for all custom drawing
var svg = d3.select("#map").select("svg"),
    g = svg.append("g").attr('id','#d3-layer');

// Function to map Lat/Lon to current svg X/Y
function project(x) {
  return map.latLngToLayerPoint(new L.LatLng(x.lat, x.lon));
}

// Basic line drawing function
var track = d3.svg.line()
    .x(function(d) { return d.x })
    .y(function(d) { return d.y });

// Hand entered positions for all race marks
// Computed by taking mean pos of the specific mark boats GPS track
var marks = [{lat:37.820190,lon:-122.456763,label:'Entry'},
             {lat:37.81705,lon:-122.455,label:'Start Gate (Stb)'},
             {lat:37.81746,lon:-122.4519,label:'Start Gate (Port)'},
             {lat:37.81284,lon:-122.4505,label:'Mark 1 (Port)'},
             {lat:37.82368,lon:-122.4008,label:'Leeward Gate (Port)'},
             {lat:37.82227,lon:-122.4004,label:'Leeward Gate (Stb)'},
             {lat:37.81286,lon:-122.4624,label:'Windward Gate (Stb)'},
             {lat:37.81437,lon:-122.4631,label:'Windward Gate (Port)'},
             {lat:37.81023,lon:-122.4012,label:'Finish Gate (Stb)'},
             {lat:37.81039,lon:-122.3993,label:'Finish Gate (Port)'}];

// Add marks to mark-group
var markGroup = g.append('g').attr('id','mark-group');
markGroup.selectAll('.mark')
        .data(marks.map(function(d) { return project(d); }),function(d,i) { return i; })
    .enter().append('svg:circle')
        .attr('class','mark')
        .attr('r',2)
        .attr('cx',function(d) { return d.x; })
        .attr('cy',function(d) { return d.y; })
        .on('mouseout',function(d,i) { console.log(marks[i].label); });


// List of boats to load/draw
var boats = [{id:'USA',className:'usa'},
             //{id:'PRO',className:'rc'},
             //{id:'HL1',className:'heli'},
             //{id:'HL2',className:'heli'},
             //{id:'RGR',className:'marshall'},
             //{id:'SHA',className:'marshall'},
//             {id:'U1',className:'ump'},
             //{id:'U2',className:'ump'},
             //{id:'U3',className:'ump'},
             //{id:'VOL',className:'cam'},
             //{id:'WEA',className:'cam'},
             {id:'NZL',className:'nzl'}];

var curTime = timeMapper.invert(0);

// Add boat-group
var boatLayer = g.append('g').attr('id','boat-group');


var loadedBoats = 0;

// Loop through the desired boats and read the CSV file then draw track
// Each loaded CSV gets wrapped as a closure so arguments hold up
for (var i = 0; i < boats.length; i++) (function(i) {
    var boat_id = boats[i].id;
    var boat_class = boats[i].className;
    d3.csv('../data/130925/csv/20130925130025-NAV-'+boat_id+'.csv')
        .row(function(d) { 
            return {lat:d.Lat, 
                    lon:d.Lon, 
                    heading:d.Hdg,
                    courseOverGround:d.COG,
                    speedOverGround:d.SOG,
                    trueWindDir:d.CourseWindDirection,
                    trueWindSpd:d.CourseWindSpeed,
                    heel:d.Heel,
                    pitch:d.Pitch,
                    //date:formatDate.parse(d.Date),
                    time:formatTime.parse(d.LocalTime),
                    //both:format.parse(d.Date+' '+d.LocalTime+' '+d.Zone+'00')
                    }; })
        .get(function(error,rows) { 
          
            // Save the loaded data to global object
            //track_points[boat_id] = rows;  
            boats[i].tracks = rows;
            updateBoatLoadingProgress(++loadedBoats);

         });
})(i);

function toDegrees (angle) {
      return angle * (180 / Math.PI);
}

function toRadians (angle) {
      return angle * (Math.PI / 180);
}

var updateBoatLoadingProgress = function(progress) {
    // FIXME Actually show some sort of progress bar
    console.log(progress);
    if (progress == boats.length) {
        updateBoats();
    }
};
// Bisector accessor function to quickly find the index of the track array associated
// with the currently selected time
var bisect = d3.bisector(function(d) { return d.time; }).right 

var getBoatPosIdx = function(d) {
    // FIXME We need to do something smarter if the current timepoint is not in
    // the array... Right now we are only looking to see if we have gone past
    // the end... What if the current time is before we have any data? Should
    // fade out or hide the marker maybe? Do the same thing on boat addition.

    var point = bisect(d.tracks,curTime); 
    point = point < d.tracks.length ? point : d.tracks.length-1
    return project(d.tracks[point]); 
} 

var getBoatAtTime = function(d) { 
    var point = bisect(d.tracks,curTime);
    point = point < d.tracks.length ? point : d.tracks.length-1
    return d.tracks[point];
}

var getApparentWind = function(d) { 
    var d = getBoatAtTime(d); 
    var x = (d.trueWindSpd * Math.cos(toRadians(d.trueWindDir)-Math.PI/2)) +
                           (d.speedOverGround * Math.cos(toRadians(d.courseOverGround)-Math.PI/2));
    var y = (d.trueWindSpd * Math.sin(toRadians(d.trueWindDir)-Math.PI/2)) + 
                    	   (d.speedOverGround * Math.sin(toRadians(d.courseOverGround)-Math.PI/2)); 

    return {x:x,y:y};
};

var updateBoats = function () {
        // Create a group for the specific boat
        var boatGroup = boatLayer.selectAll('.boat-group')
                .data(boats,function(d) { return d.id });

        var newBoatGroup = boatGroup.enter().append('svg:g')
                .attr('id',function(d) { return 'boat-group-'.concat(d.id); })
                .attr('class','boat-group');
            
        // Update the existing boat tracks
        boatGroup.selectAll('.track')
                .attr("d",function(d) { return track(d.tracks.map(function(d) { return project(d); })) });

        // Add the new tracks to the boat group
        newBoatGroup.append('svg:path')
                .attr("d",function(d) { return track(d.tracks.map(function(d) { return project(d); })) })
                .attr('id',function(d) { return 'track-'.concat(d.id); })
                .attr('class',function(d) { return 'track track-'.concat(d.className); });

        // Add new boat marker groups
        var newBoatMarkerGroup = newBoatGroup.append('svg:g')
                .attr('id',function(d) { return 'boat-icon-'.concat(d.id); })
                .attr('class',function(d) { return 'boat-icon boat-icon-'.concat(d.className); })
                .attr('transform',function(d) { var pt = getBoatPosIdx(d);
                        return 'translate('+pt.x+','+pt.y+')'; });

        // Add new boat location markers
        newBoatMarkerGroup.append('svg:circle')
                .attr('id',function(d) { return 'boat-marker-'.concat(d.id); })
                .attr('class',function(d) { return 'boat-marker boat-marker-'.concat(d.className); })
                .attr('r',3)
                .attr('cx',0)
                .attr('cy',0);

        // Add new boat stats group
        var newBoatStats = newBoatMarkerGroup.append('svg:g')
                .attr('id',function(d) { return 'boat-stats-'.concat(d.id); })
                .attr('class',function(d) { return 'boat-stats boat-stats-'.concat(d.className); })

        // Add new boat true wind arrow
        newBoatStats.append('svg:line')
            .attr('id',function(d) { return 'boat-stats-truewind-'.concat(d.id); })
            .attr('class',function(d) { return 'boat-stats-truewind boat-stats-truewind-'.concat(d.className); })
            .attr('x1',0).attr('y1',0)
            .attr('x2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.trueWindSpd * Math.cos(toRadians(d.trueWindDir)-Math.PI/2); })
            .attr('y2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.trueWindSpd * Math.sin(toRadians(d.trueWindDir)-Math.PI/2); });

        // Add new boat apparent wind arrow
        newBoatStats.append('svg:line')
            .attr('id',function(d) { return 'boat-stats-appwind-'.concat(d.id); })
            .attr('class',function(d) { return 'boat-stats-appwind boat-stats-appwind-'.concat(d.className); })
            .attr('x1',0).attr('y1',0)
            .attr('x2',function(d) { 
                return getApparentWind(d).x; })
            .attr('y2',function(d) { 
                return getApparentWind(d).y; });

        // Add new boat velocity arrow
        newBoatStats.append('svg:line')
            .attr('id',function(d) { return 'boat-stats-velocity-'.concat(d.id); })
            .attr('class',function(d) { return 'boat-stats-velocity boat-stats-velocity-'.concat(d.className); })
            .attr('x1',0).attr('y1',0)
            .attr('x2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.speedOverGround * Math.cos(toRadians(d.courseOverGround)-Math.PI/2); })
            .attr('y2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.speedOverGround * Math.sin(toRadians(d.courseOverGround)-Math.PI/2); });

        // Update display table 
        var trs = d3.select('#summary-table tbody').selectAll('tr')
                    .data(boats,function(d) { return d.id });

        // Add new rows to table
        var newTRs = trs.enter().append('tr')
            .attr('class',function(d) { return 'summary-table-row summary-table-row-'.concat(d.className); });
        newTRs.append('td').text(function(d) { return d.id; });
        newTRs.append('td').text(function(d) { var d = getBoatAtTime(d); return d.speedOverGround; });
        newTRs.append('td').text(function(d) { var d = getBoatAtTime(d); return d.heading; });
        newTRs.append('td').text(function(d) { return getApparentWind(d).x; });
        newTRs.append('td').text(function(d) { return getApparentWind(d).y; });

        // Update existing specific boat icon details
        updateBoatPos(ts.slider().val());

}

// Function that gets called on map redraw (usually zoom) to fix plotted
// positions so they correspond to proper lat/lon
var updateView = function() {
    // Update mark positions
    g.selectAll('.mark')
        .data(marks.map(function(d) { return project(d); }),function(d,i) { return i; })
        .attr('cx',function(d) { return d.x; })
        .attr('cy',function(d) { return d.y; });
    
    updateBoats();
};

// Move the marker to a new position in time
var updateBoatPos = function(pos) {

    curTime = timeMapper.invert(pos);

    // Move marker to current location
    var icons = g.selectAll('.boat-icon')
            .attr('transform',function(d) { var pt = getBoatPosIdx(d);
                    return 'translate('+pt.x+','+pt.y+')'; });

    // Update boat stats
    icons.selectAll('.boat-stats-truewind')
            .attr('x2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.trueWindSpd * Math.cos(toRadians(d.trueWindDir)-Math.PI/2); })
            .attr('y2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.trueWindSpd * Math.sin(toRadians(d.trueWindDir)-Math.PI/2); });
    icons.selectAll('.boat-stats-appwind')
            .attr('x2',function(d) { 
                return getApparentWind(d).x; })
            .attr('y2',function(d) { 
                return getApparentWind(d).y; })
    icons.selectAll('.boat-stats-velocity')
            .attr('x2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.speedOverGround * Math.cos(toRadians(d.courseOverGround)-Math.PI/2); })
            .attr('y2',function(d) { 
                    var d = getBoatAtTime(d); 
                    return d.speedOverGround * Math.sin(toRadians(d.courseOverGround)-Math.PI/2); });

    // Update boat summary table
    var trs = d3.select('#summary-table tbody').selectAll('tr')
            .data(boats,function(d) { return d.id });

    trs.selectAll('td').data(function(d) {
           var id = d.id;
           var b = getBoatAtTime(d); 
           return [id, b.speedOverGround, b.heading, getApparentWind(d).x, getApparentWind(d).y]; })
        .text(function(d) { return d; });

};

map.on("viewreset",updateView)
      </script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
  </body>
</html>

